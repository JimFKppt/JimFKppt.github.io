---
title: Theory：Decorator
date: 2022-10-17 20:41:05
permalink: /pages/c37d64/
tags:
  - Pattern
---
Sometimes it is necessary to impose additional responsibilities on a separate object rather than the whole class. A library for building graphics in the user interface should be able to add a new property, say, frames or new behavior (for example, the ability to scroll to any element). Adding new responsibilities is permissible through inheritance. However, this solution is static, and therefore not flexible enough.

## Decorator

A more flexible approach is to put the component in another object called the **decorator.** The Decorator is a structural pattern used to add new responsibilities to an object dynamically without extending functionality. That lets you dynamically change the behavior of an object at runtime by wrapping it in an object of a decorator class.

Decorators are used for adding some behavior that is not part of the core functionality to all interface methods. Decorator pattern perfectly suits the following tasks:

- caching the work results;
- measuring the execution time of methods;
- user access control.

The decorator pattern has the following components:

- *Component* is the interface for the objects that will get new responsibilities from the decorators;
- *Concrete Component* defines objects which implement the Component interface and will get new responsibilities from the concrete decorators;
- *Decorator* has reference to the Component and overridden component methods;
- *Concrete Decorator* extends Decorator class and adds new functions, properties or state without creating new classes;

![img](https://ucarecdn.com/8422f83b-451b-442a-8588-86ec6507b72f/)




The decorator pattern in JDK:

- Streams: java.io package;
- Collections: java.util package.

## Practical example

Let’s consider a more specific example. Our components are software developers that have to make some job, that’s why we create the Developer interface:

```java
public interface Developer {

    public String makeJob();
}
```

Next, we create a concrete developer:

```java
public class JavaDeveloper implements Developer {

    public String makeJob() {
        return "Write Java Code.";
    }
}
```

Now, describe the developer decorator to add functionality to our developers dynamically:

```java
public class DeveloperDecorator implements Developer {
    private Developer developer;

    public DeveloperDecorator(Developer developer) {
        this.developer = developer;
    }

    public String makeJob() {
        return developer.makeJob();
    }
}
```

The concrete decorator is the senior java developer who has an important additional responsibility: code review.

```java
public class SeniorJavaDeveloper extends DeveloperDecorator {

    public SeniorJavaDeveloper(Developer developer) {
        super(developer);
    }

 
    public String makeCodeReview() {
        return "Make code review.";
    }

    public String makeJob() {
        return super.makeJob() + " " + makeCodeReview();
    }
}
```

The second decorator is the team leader: being also a developer, the leader additionally has to communicate with customers and send weekly reports:

```java
public class JavaTeamLead extends DeveloperDecorator {

    public JavaTeamLead(Developer developer) {
        super(developer);
    }

    public String sendWeekReport() {
        return "Send week report to customers.";
    }

    public String makeJob() {
        return super.makeJob() + " " + sendWeekReport();
    }
}
```

Here is the final demo of the Decorator pattern:

```java
public class Task {

    public static void main(String[] args) {
        Developer developer = new JavaTeamLead(
                                  new SeniorJavaDeveloper(
                                      new JavaDeveloper()));
        
        System.out.println(developer.makeJob());
    }
}
```

## Conclusion

The decorator pattern is applicable in the following cases:

- When you want to add new properties and functions to the object dynamically;
- When the extension of classes is superfluous.