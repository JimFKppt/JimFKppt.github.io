(window.webpackJsonp=window.webpackJsonp||[]).push([[150],{649:function(e,t,a){"use strict";a.r(t);var n=a(21),i=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("div",{staticStyle:{"background-image":"url(https://cdn.jsdelivr.net/gh/JimFKppt/Pictures@master/static_files/img/milad-fakurian-UiiHVEyxtyA-unsplash.jpg)","background-size":"cover"}},[a("iframe",{attrs:{src:e.$withBase("/markmap/Markmap_Theory：IoC container.html"),width:"100%",height:"450",frameborder:"0",scrolling:"No",leftmargin:"0",topmargin:"0"}})]),e._v(" "),a("p",[a("strong",[e._v("IoC")]),e._v(", which stands for "),a("strong",[e._v("Inversion of Control")]),e._v(", is the mechanism used by Spring to implement dependency injection. When we create applications, we often need different objects to implement various functionalities. Some objects will need to use other objects as their dependencies, which in turn may require other objects, and so on. In order to simplify this long and complex process, Spring uses dependency injection.")]),e._v(" "),a("p",[e._v("Using the IoC process, objects can define the dependencies they need to run successfully. These dependencies are defined through constructor arguments, factory method arguments, or properties set on the object instance. In this topic, we will overview the components of IoC, and see how they work together to create the dependency injection functionality.")]),e._v(" "),a("h2",{attrs:{id:"spring-container"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-container"}},[e._v("#")]),e._v(" Spring container")]),e._v(" "),a("p",[e._v("When we need to have a ready-to-use spring application, we need a few components to help implement the required functionality. The image below shows a typical structure of a Spring application.")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://ucarecdn.com/29050dd5-2aa6-494e-ba1d-ca782213ddc2/",alt:"img"}})]),e._v(" "),a("p",[e._v("Let's start by looking at the Spring container since it is the core of the Spring framework. The Spring container manages the lifecycle application from start to finish. It manages various components created for the application and handles any required dependency injections. The Spring container can be configured through metadata in a number of ways. There are two types of metadata that are used in Spring: "),a("strong",[e._v("XML")]),e._v(" and "),a("strong",[e._v("annotations")]),e._v(". The XML approach involves defining class-related data in an external XML file, which can then be loaded and used in the Spring application.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),a("p",[e._v("In our topics, we use the annotation-based approach, and it is recommended for all new Spring-based applications.")])]),e._v(" "),a("p",[e._v("The annotation-based approach involves adding annotations to simple classes in order to provide context and functionality for Spring. These annotations will start with the "),a("code",[e._v("@")]),e._v(" character, and provide a specific value that we wish to add to our class. These values will allow us to build objects with the required features and configurations. These objects are known as "),a("strong",[e._v("POJO classes")]),e._v(", and in the next section, we will see how they fit into the Spring framework.")]),e._v(" "),a("h2",{attrs:{id:"pojo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pojo"}},[e._v("#")]),e._v(" POJO")]),e._v(" "),a("p",[e._v("In the previous diagram, we saw that the Spring container takes in a POJO class. The term "),a("strong",[e._v("POJO")]),e._v(" stands for "),a("strong",[e._v("Plain Old Java Object")]),e._v(". A POJO is the most basic type of an object and it contains no ties to frameworks. This means that POJOs are valid objects for any application. The idea of a POJO is that it is the simplest possible unit of code available for an application. They can implement properties, as well as getters and setters for these properties, but cannot extend or implement framework-specific classes and interfaces classes or contain annotations.")]),e._v(" "),a("p",[e._v("The simplicity of POJO makes them ideal building blocks for any application component we need to implement. Beside POJOs, Spring can use a special type of POJO called "),a("strong",[e._v("JavaBean")]),e._v(". With "),a("strong",[e._v("JavaBeans")]),e._v(", we add a few more requirements: for example, classes are required to be serializable. In addition, they require private fields and a no-argument constructor to be available. These classes can also be customized and configured using Spring metadata. To do this, we can add various annotations to the classes we create in Spring. For example, the "),a("code",[e._v("@Bean")]),e._v(" annotation can be added to a factory method to define that the class it produces is a "),a("strong",[e._v("Spring Bean")]),e._v(" which means an object managed by the IoC container. With these annotations, it is possible to add any configurations to preexisting classes without the need for creating additional files. This will allow you to take full advantage of the features provided by Spring.")]),e._v(" "),a("p",[e._v("To sum it all up: POJO is a simple object which doesn't depend on the framework; Java Bean is a POJO with some additional requirements and restrictions; and Spring Bean is POJO or JavaBean created and managed by an instance of the Spring IoC container.")]),e._v(" "),a("h2",{attrs:{id:"contexts-and-bean-factory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contexts-and-bean-factory"}},[e._v("#")]),e._v(" Contexts and bean factory")]),e._v(" "),a("p",[e._v("When we work with the Spring IoC, there are two components we should be aware of. The first one is the "),a("code",[e._v("BeanFactory")]),e._v(", an interface that allows for configuration and management of objects. The "),a("code",[e._v("BeanFactory")]),e._v(" can be used to produce container-managed objects known as beans, which can organize the backbone of your application. These beans look like regular Java objects, but they can be created during application startup, registered, and injected into different parts of the application by the container.")]),e._v(" "),a("p",[e._v("The second component is the "),a("code",[e._v("ApplicationContext")]),e._v(", which is a sub-interface of the "),a("code",[e._v("BeanFactory")]),e._v(". The goal of the "),a("code",[e._v("ApplicationContext")]),e._v(" is to facilitate integration with Spring's Aspect Oriented Programming (AOP) functionality. This functionality includes a variety of components, ranging from message resource handling to application layer-specific contexts. There are three main "),a("code",[e._v("ApplicationContext")]),e._v(" implementations that we typically see in applications:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("FileSystemXmlApplicationContext")])]),e._v(" "),a("li",[a("code",[e._v("ClassPathXmlApplicationContext")])]),e._v(" "),a("li",[a("code",[e._v("WebApplicationContext")])])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("FileSystemXmlApplicationContext")]),e._v(" will load bean definitions from an XML file that is provided as a full file system path to the constructor. This means that beans are initialized based on the contents of a file from the file system of the application that is being run. For "),a("code",[e._v("ClassPathXmlApplicationContext")]),e._v(", beans are still loaded from an XML file, however, the file is provided as the CLASSPATH property rather than a full system path in the constructor. Finally, "),a("code",[e._v("WebApplicationContext")]),e._v(" is generally used to set the configuration of a web application in Spring. When using "),a("code",[e._v("WebApplicationContext")]),e._v(", you will often set the servlet configuration within a "),a("code",[e._v("web.xml")]),e._v(" file. Inside this file, you can specify configurations for each servlet that the application uses.")]),e._v(" "),a("p",[e._v("With our "),a("code",[e._v("ApplicationContext")]),e._v(", we can configure the Spring IoC container, allowing us to create an application that is ready for use.")]),e._v(" "),a("h2",{attrs:{id:"conclusion"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion")]),e._v(" "),a("p",[e._v("The IoC container in Spring enables many important mechanisms required to create applications. With the IoC, we can create "),a("code",[e._v("ApplicationContext")]),e._v(" objects, which can provide important configurations for the application setup. In addition, it allows us to create POJO objects such as Java beans, which can be used to create our own entities in the application. These entities can help us bring life to our app, and achieve the required functionality for it to do its job the best way possible. You will learn how to use IoC to create Spring Beans in practice in subsequent topics.")])])}),[],!1,null,null,null);t.default=i.exports}}]);